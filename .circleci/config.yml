version: 2.1

orbs:
  gcp-gcr: circleci/gcp-gcr@0.16.3
  gcp-cloud-run: circleci/gcp-cloud-run@1.0.2

commands:
  install-aws-cli:
    steps:
      - run:
          name: Install AWS CLI
          command: |
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip awscliv2.zip
            sudo ./aws/install
            echo 'export PATH=/usr/local/bin:$PATH' >> $BASH_ENV
            source $BASH_ENV
            aws --version
      - run:
          name: Configure AWS
          command: |
            source $BASH_ENV
            aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
            aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
            aws configure set default.region $AWS_DEFAULT_REGION

  install-gcloud:
    steps:
      - run:
          name: Install gcloud
          command: |
            export CLOUDSDK_CORE_DISABLE_PROMPTS=1
            export CLOUDSDK_INSTALL_DIR=$HOME
            curl -sSL https://sdk.cloud.google.com | bash
            source "$HOME/google-cloud-sdk/path.bash.inc"
            echo 'source "$HOME/google-cloud-sdk/path.bash.inc"' >> $BASH_ENV
            gcloud version
      - run:
          name: Authenticate GCP
          command: |
            source $BASH_ENV
            echo "$GCLOUD_SERVICE_KEY" > creds.json
            gcloud auth activate-service-account --key-file=creds.json
            gcloud config set project "$GOOGLE_PROJECT_ID"

parameters:
  deploy-aws:
    type: boolean
    default: true
  deploy-gcp:
    type: boolean
    default: true

jobs:
  test:
    docker:
      - image: cimg/node:18.20
    steps:
      - checkout
      - setup_remote_docker
      - restore_cache:
          keys:
            - v1-dependencies-{{ checksum "package.json" }}
            - v1-dependencies-
      - run:
          name: Install dependencies
          command: npm install
      - save_cache:
          paths:
            - node_modules
          key: v1-dependencies-{{ checksum "package.json" }}
      - run:
          name: Run tests
          command: npm test
      - run:
          name: Test Docker build
          command: docker build -t multi-cloud-demo:test .

  build-and-push-aws:
    docker:
      - image: cimg/node:18.20
    steps:
      - checkout
      - setup_remote_docker
      - install-aws-cli
      - run:
          name: Configure ECR authentication
          command: |
            source $BASH_ENV
            aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
      - run:
          name: Create ECR repository if it doesn't exist
          command: |
            source $BASH_ENV
            echo "Checking if ECR repository 'multi-cloud-demo' exists..."
            if ! aws ecr describe-repositories --repository-names multi-cloud-demo --region $AWS_DEFAULT_REGION > /dev/null 2>&1; then
              echo "Repository doesn't exist. Creating ECR repository..."
              aws ecr create-repository --repository-name multi-cloud-demo --region $AWS_DEFAULT_REGION
              echo "ECR repository 'multi-cloud-demo' created successfully!"
            else
              echo "ECR repository 'multi-cloud-demo' already exists."
            fi
      - run:
          name: Build and push Docker image to ECR
          command: |
            DEPLOYMENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            APP_VERSION=${CIRCLE_SHA1:0:7}
            ECR_REPO="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/multi-cloud-demo"

            echo "Building Docker image..."
            docker build \
              --build-arg DEPLOYMENT_TIME=$DEPLOYMENT_TIME \
              --build-arg APP_VERSION=$APP_VERSION \
              -t $ECR_REPO:latest \
              -t $ECR_REPO:${CIRCLE_SHA1} \
              .

            echo "Pushing Docker image..."
            docker push $ECR_REPO:latest
            docker push $ECR_REPO:${CIRCLE_SHA1}

  build-and-push-gcp:
    docker:
      - image: cimg/node:18.20
    steps:
      - checkout
      - setup_remote_docker
      - install-gcloud
      - run:
          name: Configure Docker for GCR
          command: |
            source $BASH_ENV
            gcloud auth configure-docker gcr.io
      - gcp-gcr/build-image:
          image: multi-cloud-demo
          tag: "latest,${CIRCLE_SHA1}"
          dockerfile: Dockerfile
          registry-url: gcr.io
          extra_build_args: |
            --build-arg DEPLOYMENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            --build-arg APP_VERSION=${CIRCLE_SHA1:0:7}
      - gcp-gcr/push-image:
          image: multi-cloud-demo
          tag: "latest,${CIRCLE_SHA1}"
          registry-url: gcr.io

  deploy-to-aws:
    docker:
      - image: cimg/node:18.20
    steps:
      - checkout
      - install-aws-cli
      - run:
          name: Replace placeholders in task definition
          command: |
            sed -i "s/{AWS_ACCOUNT_ID}/$AWS_ACCOUNT_ID/g" aws/task-definition.json
            sed -i "s/{ECR_REPOSITORY_URI}/$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com\/multi-cloud-demo/g" aws/task-definition.json
            sed -i "s/{AWS_REGION}/$AWS_DEFAULT_REGION/g" aws/task-definition.json
            sed -i "s/{CIRCLE_SHA1}/${CIRCLE_SHA1}/g" aws/task-definition.json
      - run:
          name: Create ECS cluster if it doesn't exist
          command: |
            source $BASH_ENV
            echo "Checking if ECS cluster 'multi-cloud-cluster' exists..."
            if ! aws ecs describe-clusters --clusters multi-cloud-cluster --region $AWS_DEFAULT_REGION --query 'clusters[0].status' --output text 2>/dev/null | grep -q "ACTIVE"; then
              echo "Cluster doesn't exist. Creating ECS cluster..."
              aws ecs create-cluster --cluster-name multi-cloud-cluster --region $AWS_DEFAULT_REGION
              echo "ECS cluster 'multi-cloud-cluster' created successfully!"
              
              # Wait a moment for cluster to be ready
              echo "Waiting for cluster to be active..."
              sleep 10
            else
              echo "ECS cluster 'multi-cloud-cluster' already exists and is active."
            fi
      - run:
          name: Register task definition
          command: |
            source $BASH_ENV
            echo "Registering task definition..."
            aws ecs register-task-definition \
              --cli-input-json file://aws/task-definition.json \
              --region $AWS_DEFAULT_REGION
      - run:
          name: Create or update ECS service
          command: |
            source $BASH_ENV
            echo "Checking if ECS service exists..."
            if aws ecs describe-services \
              --cluster multi-cloud-cluster \
              --services multi-cloud-demo-service \
              --region $AWS_DEFAULT_REGION \
              --query 'services[0].status' \
              --output text 2>/dev/null | grep -q "ACTIVE"; then
              echo "Service exists, updating..."
              aws ecs update-service \
                --cluster multi-cloud-cluster \
                --service multi-cloud-demo-service \
                --task-definition multi-cloud-demo \
                --region $AWS_DEFAULT_REGION
            else
              echo "Service does not exist, creating..."
              # Get default VPC and subnet
              VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text --region $AWS_DEFAULT_REGION)
              SUBNET_ID=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[0].SubnetId' --output text --region $AWS_DEFAULT_REGION)
              
              # Create or get security group
              SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=multi-cloud-demo-sg" --query 'SecurityGroups[0].GroupId' --output text --region $AWS_DEFAULT_REGION 2>/dev/null)
              if [ "$SG_ID" == "None" ] || [ -z "$SG_ID" ]; then
                echo "Creating security group..."
                SG_ID=$(aws ec2 create-security-group \
                  --group-name multi-cloud-demo-sg \
                  --description "Security group for multi-cloud demo" \
                  --vpc-id $VPC_ID \
                  --region $AWS_DEFAULT_REGION \
                  --query 'GroupId' --output text)
                
                # Allow HTTP traffic
                aws ec2 authorize-security-group-ingress \
                  --group-id $SG_ID \
                  --protocol tcp \
                  --port 3000 \
                  --cidr 0.0.0.0/0 \
                  --region $AWS_DEFAULT_REGION
              fi
              
              aws ecs create-service \
                --cluster multi-cloud-cluster \
                --service-name multi-cloud-demo-service \
                --task-definition multi-cloud-demo \
                --desired-count 1 \
                --launch-type FARGATE \
                --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_ID],securityGroups=[$SG_ID],assignPublicIp=ENABLED}" \
                --region $AWS_DEFAULT_REGION
            fi

  deploy-to-gcp:
    docker:
      - image: cimg/node:18.20
    steps:
      - checkout
      - install-gcloud
      - run:
          name: Replace placeholders in service definition
          command: |
            sed -i "s/{GCP_PROJECT_ID}/$GOOGLE_PROJECT_ID/g" gcp/service.yaml
            sed -i "s/{GCP_REGION}/$GOOGLE_COMPUTE_REGION/g" gcp/service.yaml
            sed -i "s/:latest/:${CIRCLE_SHA1}/g" gcp/service.yaml
      - gcp-cloud-run/deploy:
          platform: managed
          image: gcr.io/$GOOGLE_PROJECT_ID/multi-cloud-demo:${CIRCLE_SHA1}
          service-name: multi-cloud-demo
          region: $GOOGLE_COMPUTE_REGION
          unauthenticated: true

  verify-deployments:
    # This job verifies both AWS and GCP deployments are successful
    # For AWS: Shows the public IP and port (tutorial approach)
    # For GCP: Shows the Cloud Run URL
    # 
    # ADVANCED: For production AWS deployments, consider adding an Application Load Balancer (ALB)
    # to get a stable DNS name instead of relying on task public IPs which can change.
    # See AWS documentation: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/
    docker:
      - image: cimg/node:18.20
    steps:
      - install-aws-cli
      - install-gcloud
      - run:
          name: Verify AWS ECS deployment
          command: |
            source $BASH_ENV
            echo "Verifying AWS ECS deployment..."

            # Check service status
            SERVICE_STATUS=$(aws ecs describe-services \
              --cluster multi-cloud-cluster \
              --services multi-cloud-demo-service \
              --region $AWS_DEFAULT_REGION \
              --query 'services[0].status' \
              --output text)

            echo "ECS Service Status: $SERVICE_STATUS"

            if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
              echo "SUCCESS: AWS ECS service is active and running"

              # Get running task ARN - wait for tasks to start if needed
              echo "Getting task details..."
              TASK_ARN=""
              for i in {1..6}; do
                TASK_ARN=$(aws ecs list-tasks \
                  --cluster multi-cloud-cluster \
                  --service-name multi-cloud-demo-service \
                  --region $AWS_DEFAULT_REGION \
                  --desired-status RUNNING \
                  --query 'taskArns[0]' \
                  --output text)
                
                if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
                  break
                else
                  echo "Waiting for task to start... (attempt $i/6)"
                  sleep 10
                fi
              done
              
              if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
                echo "Found running task: $(basename $TASK_ARN)"
                
                # Get network interface ID
                ENI_ID=$(aws ecs describe-tasks \
                  --cluster multi-cloud-cluster \
                  --tasks $TASK_ARN \
                  --region $AWS_DEFAULT_REGION \
                  --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
                  --output text)
                
                if [ -n "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
                  echo "Network interface: $ENI_ID"
                  
                  # Get public IP
                  PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                    --network-interface-ids $ENI_ID \
                    --region $AWS_DEFAULT_REGION \
                    --query 'NetworkInterfaces[0].Association.PublicIp' \
                    --output text)
                  
                  if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
                    echo ""
                    echo "======================================="
                    echo "AWS DEPLOYMENT SUCCESSFUL!"
                    echo "Service URL: http://$PUBLIC_IP:3000"
                    echo "======================================="
                    echo ""
                    
                    # Test connectivity (optional)
                    echo "Testing connectivity..."
                    if curl -f --max-time 10 --retry 2 "http://$PUBLIC_IP:3000" > /dev/null 2>&1; then
                      echo "SUCCESS: Service is responding to HTTP requests"
                    else
                      echo "NOTE: Service URL found but may still be starting up"
                    fi
                  else
                    echo "Public IP not yet assigned. Service is running but not externally accessible."
                    echo "NOTE: For production, consider using an Application Load Balancer (ALB)"
                  fi
                else
                  echo "Network interface not found for task"
                fi
              else
                echo "No running tasks found - investigating deployment issues..."
                
                # Check service events for errors
                echo ""
                echo "=== ECS Service Events (last 10) ==="
                aws ecs describe-services \
                  --cluster multi-cloud-cluster \
                  --services multi-cloud-demo-service \
                  --region $AWS_DEFAULT_REGION \
                  --query 'services[0].events[:10].[createdAt,message]' \
                  --output table || echo "Could not retrieve service events"
                
                # Check for stopped tasks and their reasons
                echo ""
                echo "=== Recent Stopped Tasks ==="
                STOPPED_TASKS=$(aws ecs list-tasks \
                  --cluster multi-cloud-cluster \
                  --service-name multi-cloud-demo-service \
                  --region $AWS_DEFAULT_REGION \
                  --desired-status STOPPED \
                  --query 'taskArns[:3]' \
                  --output text)
                
                if [ "$STOPPED_TASKS" != "None" ] && [ -n "$STOPPED_TASKS" ]; then
                  for task in $STOPPED_TASKS; do
                    echo "Task: $(basename $task)"
                    aws ecs describe-tasks \
                      --cluster multi-cloud-cluster \
                      --tasks $task \
                      --region $AWS_DEFAULT_REGION \
                      --query 'tasks[0].{StoppedReason:stoppedReason,StoppedAt:stoppedAt,LastStatus:lastStatus}' \
                      --output table
                  done
                else
                  echo "No stopped tasks found"
                fi
                
                # Check current service configuration
                echo ""
                echo "=== Service Configuration Issues ==="
                aws ecs describe-services \
                  --cluster multi-cloud-cluster \
                  --services multi-cloud-demo-service \
                  --region $AWS_DEFAULT_REGION \
                  --query 'services[0].{DesiredCount:desiredCount,RunningCount:runningCount,PendingCount:pendingCount,TaskDefinition:taskDefinition}' \
                  --output table
                
                echo ""
                # Check if required IAM role exists
                echo ""
                echo "=== IAM Role Check ==="
                if aws iam get-role --role-name ecsTaskExecutionRole --region $AWS_DEFAULT_REGION > /dev/null 2>&1; then
                  echo "✓ ecsTaskExecutionRole exists"
                else
                  echo "✗ ecsTaskExecutionRole missing - this is likely the issue!"
                  echo "Creating ecsTaskExecutionRole..."
                  
                  # Create the role
                  aws iam create-role \
                    --role-name ecsTaskExecutionRole \
                    --assume-role-policy-document '{
                      "Version": "2012-10-17",
                      "Statement": [
                        {
                          "Effect": "Allow",
                          "Principal": {
                            "Service": "ecs-tasks.amazonaws.com"
                          },
                          "Action": "sts:AssumeRole"
                        }
                      ]
                    }' \
                    --region $AWS_DEFAULT_REGION || echo "Role creation failed"
                  
                  # Attach the policy
                  aws iam attach-role-policy \
                    --role-name ecsTaskExecutionRole \
                    --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy \
                    --region $AWS_DEFAULT_REGION || echo "Policy attachment failed"
                  
                  echo "Role created - you may need to redeploy the service"
                fi
                
                echo ""
                echo "TROUBLESHOOTING: Service is ACTIVE but no tasks are running."
                echo "This usually indicates one of these issues:"
                echo "1. Task definition has invalid configuration (CPU/memory/IAM role)"
                echo "2. Container image cannot be pulled from ECR"
                echo "3. Network configuration issues (subnets/security groups)"
                echo "4. Resource constraints (insufficient capacity)"
                echo "5. IAM permissions issues"
                echo ""
                echo "Check the service events above for specific error messages."
              fi             
            else
              echo "FAILED: AWS ECS service verification failed"
              exit 1
            fi
      - run:
          name: Verify GCP Cloud Run deployment
          command: |
            source $BASH_ENV
            echo "Verifying GCP Cloud Run deployment..."

            # Check service status
            gcloud run services describe multi-cloud-demo \
              --region=$GOOGLE_COMPUTE_REGION \
              --format="value(status.conditions[0].status)" > /tmp/status.txt

            GCP_STATUS=$(cat /tmp/status.txt)
            echo "Cloud Run Service Status: $GCP_STATUS"

            if [ "$GCP_STATUS" = "True" ]; then
              echo "SUCCESS: GCP Cloud Run service is ready and running"
              
              # Get service URL
              SERVICE_URL=$(gcloud run services describe multi-cloud-demo \
                --region=$GOOGLE_COMPUTE_REGION \
                --format="value(status.url)")
              
              echo ""
              echo "======================================="
              echo "GCP DEPLOYMENT SUCCESSFUL!"
              echo "Service URL: $SERVICE_URL"
              echo "======================================="
              echo ""
              
              # Test connectivity (optional)
              echo "Testing connectivity..."
              if curl -f --max-time 10 --retry 2 "$SERVICE_URL" > /dev/null 2>&1; then
                echo "SUCCESS: Service is responding to HTTP requests"
              else
                echo "NOTE: Service URL found but may still be starting up"
              fi
            else
              echo "FAILED: GCP Cloud Run service verification failed"
              exit 1
            fi
      - run:
          name: Multi-cloud deployment summary
          command: |
            echo ""
            echo "=================================================="
            echo "    MULTI-CLOUD DEPLOYMENT COMPLETE!"
            echo "=================================================="
            echo ""
            echo "Your application is now running on both clouds:"
            echo ""
            
            # Get AWS URL again for summary
            source $BASH_ENV
            TASK_ARN=$(aws ecs list-tasks \
              --cluster multi-cloud-cluster \
              --service-name multi-cloud-demo-service \
              --region $AWS_DEFAULT_REGION \
              --desired-status RUNNING \
              --query 'taskArns[0]' \
              --output text 2>/dev/null || echo "None")
            
            if [ "$TASK_ARN" != "None" ] && [ -n "$TASK_ARN" ]; then
              ENI_ID=$(aws ecs describe-tasks \
                --cluster multi-cloud-cluster \
                --tasks $TASK_ARN \
                --region $AWS_DEFAULT_REGION \
                --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
                --output text)
              
              if [ -n "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
                PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                  --network-interface-ids $ENI_ID \
                  --region $AWS_DEFAULT_REGION \
                  --query 'NetworkInterfaces[0].Association.PublicIp' \
                  --output text)
                
                if [ -n "$PUBLIC_IP" ] && [ "$PUBLIC_IP" != "None" ] && [ "$PUBLIC_IP" != "null" ]; then
                  echo "AWS (ECS Fargate): http://$PUBLIC_IP:3000"
                else
                  echo "AWS (ECS Fargate): Service running (IP pending)"
                fi
              fi
            fi
            
            # Get GCP URL for summary
            source $BASH_ENV
            GCP_URL=$(gcloud run services describe multi-cloud-demo \
              --region=$GOOGLE_COMPUTE_REGION \
              --format="value(status.url)" 2>/dev/null || echo "URL not available")
            echo "GCP (Cloud Run):   $GCP_URL"
            echo ""
            echo "Both services are running the same containerized Node.js app!"
            echo ""
            echo "NEXT STEPS (Advanced):"
            echo "- For production AWS deployments, add an Application Load Balancer"
            echo "- Add custom domains and SSL certificates"
            echo "- Implement blue-green or canary deployments"
            echo "- Add monitoring and logging"
            echo ""

workflows:
  # Always run tests
  test-only:
    when:
      and:
        - not: << pipeline.parameters.deploy-aws >>
        - not: << pipeline.parameters.deploy-gcp >>
    jobs:
      - test

  # AWS only deployment
  aws-deploy:
    when:
      and:
        - << pipeline.parameters.deploy-aws >>
        - not: << pipeline.parameters.deploy-gcp >>
    jobs:
      - test
      - build-and-push-aws:
          requires:
            - test
          filters:
            branches:
              only: main
      - deploy-to-aws:
          requires:
            - build-and-push-aws

  # GCP only deployment
  gcp-deploy:
    when:
      and:
        - << pipeline.parameters.deploy-gcp >>
        - not: << pipeline.parameters.deploy-aws >>
    jobs:
      - test
      - build-and-push-gcp:
          requires:
            - test
          filters:
            branches:
              only: main
      - deploy-to-gcp:
          requires:
            - build-and-push-gcp

  # Multi-cloud deployment with verification
  multi-cloud-deploy:
    when:
      and:
        - << pipeline.parameters.deploy-aws >>
        - << pipeline.parameters.deploy-gcp >>
    jobs:
      - test
      - build-and-push-aws:
          requires:
            - test
          filters:
            branches:
              only: main
      - build-and-push-gcp:
          requires:
            - test
          filters:
            branches:
              only: main
      - deploy-to-aws:
          requires:
            - build-and-push-aws
      - deploy-to-gcp:
          requires:
            - build-and-push-gcp
      - verify-deployments:
          requires:
            - deploy-to-aws
            - deploy-to-gcp
